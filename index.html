<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The 613 Mitzvot | Interactive Sefer HaChinukh</title>
    <meta
      name="description"
      content="Explore the 613 mitzvot with interactive tools, search, and filters. Based on Sefer HaChinukh. English and Hebrew. Discover, learn, and study the commandments."
    />
    <meta name="keywords" content="613 mitzvot, commandments, Sefer HaChinukh, Torah, Jewish, Judaism, interactive, English, Hebrew, parasha, mitzvah" />
    <meta property="og:title" content="The 613 Mitzvot | Interactive Sefer HaChinukh" />
    <meta property="og:description" content="Explore all 613 mitzvot interactively. Search, filter, and learn about each commandment in English and Hebrew." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.taryag.online/" />
    <meta property="og:image" content="https://www.taryag.online/images/og-image.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="The 613 Mitzvot | Interactive Sefer HaChinukh" />
    <meta name="twitter:description" content="Explore all 613 mitzvot interactively. Search, filter, and learn about each commandment in English and Hebrew." />
    <meta name="twitter:image" content="https://www.taryag.online/images/og-image.jpg" />
    <!-- Bootstrap CSS (from vendor) -->
    <link rel="stylesheet" href="vendor/bootstrap/css/bootstrap.min.css" />
    <!-- Local fonts (Cardo + Noto Serif Hebrew) -->
    <link rel="stylesheet" href="styles/fonts.css" />
    <!-- Tom Select Bootstrap theme (from vendor) -->
    <link rel="stylesheet" href="vendor/tom-select/css/tom-select.bootstrap5.css" />
    <!-- App styles -->
    <link rel="stylesheet" href="styles/app.css" />

    <!-- Favicon -->
    <link rel="icon" href="images/favicon.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#0B1321" />
  </head>
  <body>
    <!-- Subtle Beta Banner -->
    <div class="alert alert-light m-0 rounded-0 text-center py-2" role="alert" style="border-left: none; border-right: none; border-top: none; font-size: 0.9rem">
      <strong>⚠️ Beta:</strong> This project is still new and evolving. Please double-check with your own or official sources when using this information. Feedback welcome at
      <a href="mailto:moxaku@gmail.com" class="alert-link">moxaku@gmail.com</a>
    </div>

    <div class="container">
      <div class="header">
        <div class="header-top">
          <div class="header-title-wrapper">
            <h1 class="app-title">
              <span class="title-en">613</span>
              <span class="title-sep" aria-hidden="true">–</span>
              <span class="title-he" lang="he" dir="rtl">תרי״ג</span>
              <!-- <span class="title-he" lang="he" dir="rtl">תרי״ג מצוות</span> -->
            </h1>
            <div class="header-hebrew-text">
              <div class="bsd">בס״ד</div>
              <div class="based-on">מבוסס על ספר החינוך</div>
            </div>
          </div>
          <div class="subtitle">Sefer HaChinukh - Interactive Version</div>
        </div>
        <div class="header-bottom">
          <div class="search-box">
            <input type="text" id="searchInput" placeholder="Search mitzvot..." />
          </div>
          <div class="stats" id="stats">
            <!-- Stats will be loaded dynamically -->
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="filter-controls">
          <div class="primary-filters">
            <select id="typeFilter" class="filter-select">
              <option value="">All Types</option>
              <option value="Positive">Positive</option>
              <option value="Negative">Negative</option>
            </select>
            <select id="bookFilter" class="filter-select">
              <option value="">All Books</option>
            </select>
            <select id="parashaFilter" class="filter-select">
              <option value="">All Parashot</option>
            </select>
            <button id="moreFiltersBtn" class="more-filters-btn" onclick="app.toggleMoreFilters()">
              <span id="moreFiltersText">More Filters</span>
              <span id="moreFiltersIcon">▼</span>
            </button>
            <div class="language-controls" id="tableLanguageToggle" style="display: none">
              <button class="table-lang-btn active" data-lang="en" onclick="app.setTableLanguage('en')">EN</button>
              <button class="table-lang-btn" data-lang="he" onclick="app.setTableLanguage('he')">עב</button>
              <button class="table-lang-btn" data-lang="both" onclick="app.setTableLanguage('both')">Both</button>
            </div>
          </div>
          <div class="secondary-filters" id="secondaryFilters" style="display: none">
            <select id="categoryFilter" class="filter-select">
              <option value="">All Categories</option>
            </select>
            <select id="appliesToFilter" class="filter-select">
              <option value="">Applies To: All</option>
            </select>
            <select id="locationFilter" class="filter-select">
              <option value="">All Locations</option>
            </select>
            <select id="timeScopeFilter" class="filter-select">
              <option value="">All Time Scopes</option>
            </select>
          </div>
        </div>
      </div>

      <div class="loading" id="loading">
        <div class="spinner"></div>
        Loading mitzvot data...
      </div>

      <div class="error" id="error" style="display: none">Error loading mitzvot data. Please check that mitzvot_data.json is available.</div>

      <div class="table-container" id="tableContainer" style="display: none">
        <table id="mitzvotTable">
          <thead>
            <tr>
              <th class="sortable" data-sort="id">
                <span class="sort-label">#</span>
                <span class="sort-indicator"></span>
              </th>
              <th class="sortable" data-sort="type">
                <span class="sort-label">Type</span>
                <span class="sort-indicator"></span>
              </th>
              <th>Mitzvah</th>
              <th>Icons</th>
              <th>Description</th>
              <th class="sortable" data-sort="parasha">
                <span class="sort-label">Parasha</span>
                <span class="sort-indicator"></span>
              </th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody id="mitzvotTableBody">
            <!-- Table rows will be loaded dynamically -->
          </tbody>
        </table>
      </div>

      <div class="pagination" id="pagination" style="display: none">
        <!-- Pagination will be loaded dynamically -->
      </div>
    </div>

    <!-- Sidebar for details -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="app.closeSidebar()"></div>
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2 id="sidebarTitle">Mitzvah Details</h2>
        <div class="language-toggle">
          <button class="language-btn active" data-lang="en" onclick="app.setLanguage('en')">English</button>
          <button class="language-btn" data-lang="he" onclick="app.setLanguage('he')">עברית</button>
          <button class="language-btn" data-lang="both" onclick="app.setLanguage('both')">Both</button>
        </div>
        <button class="sidebar-close" onclick="app.closeSidebar()">&times;</button>
      </div>
      <div class="sidebar-content" id="sidebarContent">
        <!-- Content will be loaded dynamically -->
      </div>
    </div>

    <!-- Card Modal -->
    <div class="card-modal-overlay" id="cardModalOverlay" onclick="app.closeCardModal()"></div>
    <div class="card-modal" id="cardModal">
      <button class="card-modal-close" onclick="app.closeCardModal()">&times;</button>
      <div class="mtg-card" id="mtgCard">
        <!-- Card content will be loaded dynamically -->
      </div>
    </div>

    <!-- Tom Select library (from vendor) -->
    <script src="vendor/tom-select/js/tom-select.complete.min.js"></script>

    <!-- Lucide icons (from vendor) -->
    <script src="vendor/lucide/lucide.min.js"></script>

    <!-- SweetAlert2 (from vendor) -->
    <script src="vendor/sweetalert2/sweetalert2.all.min.js"></script>

    <!-- Embedded data for standalone file:// usage -->
    <script src="mitzvot_data_en.js"></script>
    <script src="mitzvot_data_he.js"></script>
    <!-- Precomputed images manifest to avoid probing (prevents 404 spam) -->
    <script src="images_manifest.js"></script>

    <script>
      // Version: 2025-10-20-v1 - Add image extension fallback (.png -> .jpg -> .jpeg)

      // Global helper: on image load error, try next extension; finally show placeholder
      const IMAGE_EXT_FALLBACKS = ["png", "jpg", "jpeg"];
      function loadMitzvahImageFallback(imgEl, mitzvahId) {
        try {
          const currentIndex = parseInt(imgEl.dataset.extIndex || "0", 10);
          if (currentIndex < IMAGE_EXT_FALLBACKS.length - 1) {
            const nextIndex = currentIndex + 1;
            imgEl.dataset.extIndex = String(nextIndex);
            const nextExt = IMAGE_EXT_FALLBACKS[nextIndex];
            // Hide placeholder if previously shown while retrying
            const placeholder = imgEl.nextElementSibling;
            if (placeholder && placeholder.classList.contains("mtg-card-image-placeholder")) {
              placeholder.style.display = "none";
            }
            imgEl.style.display = ""; // ensure visible
            imgEl.src = `images/${mitzvahId}.${nextExt}`;
          } else {
            // Exhausted all fallbacks: hide image, show placeholder
            imgEl.style.display = "none";
            const placeholder = imgEl.nextElementSibling;
            if (placeholder && placeholder.classList.contains("mtg-card-image-placeholder")) {
              placeholder.style.display = "flex";
            }
          }
        } catch (e) {
          // As a last resort, hide image and show placeholder
          imgEl.style.display = "none";
          const placeholder = imgEl.nextElementSibling;
          if (placeholder && placeholder.classList.contains("mtg-card-image-placeholder")) {
            placeholder.style.display = "flex";
          }
        }
      }

      // Version note: previous version 2025-10-19-v2 updated truncation with smart quotes
      // Keeping class definition below unchanged except for image rendering
      // to use the new fallback handler.
      //
      // End of global helpers

      // Version: 2025-10-19-v2 - Updated truncation with smart quotes
      class MitzvotApp {
        constructor() {
          this.data = null;
          this.heData = null;
          this.filteredData = [];
          this.currentPage = 1;
          this.itemsPerPage = 50;
          this.sortField = "id";
          this.sortDirection = "asc";
          this.currentLanguage = "en";
          this.tableLanguage = "en"; // Language for table descriptions
          this.currentMitzvahId = null;
          this.moreFiltersVisible = false;

          // Feature flags
          // Disable MTG-style card previews for now
          this.cardsEnabled = false;

          // Track which mitzvot have images available
          this.mitzvotWithImages = new Set();

          // Tom Select instances map
          this.selects = {
            type: null,
            book: null,
            parasha: null,
            category: null,
            appliesTo: null,
            location: null,
            timeScope: null,
          };

          this.init();
        }

        async init() {
          try {
            await this.loadData();
            this.initImagesFromManifest();
            this.setupEventListeners();
            this.enhanceSelects();
            this.render();
          } catch (error) {
            console.error("Error initializing app:", error);
            this.showError();
          }
        }

        enhanceSelects() {
          // Helper to init Tom Select with clear button
          const initTS = (selector, key) => {
            const el = document.querySelector(selector);
            if (!el) return;
            try {
              // Destroy existing instance if any
              if (this.selects[key] && this.selects[key].destroy) {
                this.selects[key].destroy();
              }
              this.selects[key] = new TomSelect(el, {
                create: false,
                allowEmptyOption: true,
                plugins: ["clear_button"],
                maxItems: 1,
                render: {
                  option: (data, escape) => `<div>${escape(data.text)}</div>`,
                },
              });
            } catch (e) {
              console.warn("Tom Select init failed for", selector, e);
            }
          };

          initTS("#typeFilter", "type");
          initTS("#bookFilter", "book");
          initTS("#parashaFilter", "parasha");
          initTS("#categoryFilter", "category");
          initTS("#appliesToFilter", "appliesTo");
          initTS("#locationFilter", "location");
          initTS("#timeScopeFilter", "timeScope");
        }

        // Helper function to truncate text at sentence end
        truncateText(text, maxLength = 120) {
          if (!text || text.length <= maxLength) return text;

          // Find the nearest sentence ending after maxLength
          // Look for period, exclamation, or question mark, optionally followed by quotes/tags, then space or end
          // Includes both regular quotes and smart quotes (U+201C, U+201D, U+2018, U+2019)
          const sentenceEnders = /[.!?]["'»\u201C\u201D\u2018\u2019]?[)\]>]?(?:\s|$)/g;
          let match;
          let lastSentenceEnd = -1;

          // Debug for first mitzvah only
          const isDebug = text.includes("Bereshit") && text.includes("procreation");
          if (isDebug) {
            console.log("Truncating:", text.substring(0, 50) + "...");
            console.log("Text length:", text.length, "maxLength:", maxLength);
          }

          // Find all sentence endings up to and slightly beyond maxLength
          while ((match = sentenceEnders.exec(text)) !== null) {
            // Get the position right after the sentence-ending punctuation (including any trailing quotes/brackets)
            const endPosition = match.index + match[0].trimEnd().length;

            if (isDebug) {
              console.log("Found match at", match.index, "ending at", endPosition, ":", match[0]);
            }

            // If we found a sentence ending before maxLength, keep track of it
            if (endPosition <= maxLength) {
              lastSentenceEnd = endPosition;
            }
            // If we found one after maxLength, use it and stop
            else if (endPosition > maxLength) {
              if (isDebug) console.log("Using sentence after maxLength, result length:", endPosition);
              return text.substring(0, endPosition).trim();
            }
          }

          // If we found a sentence ending before maxLength, use it
          if (lastSentenceEnd > 0) {
            return text.substring(0, lastSentenceEnd).trim();
          }

          // If no sentence ending found, fall back to word boundary
          const truncated = text.substring(0, maxLength);
          const lastSpace = truncated.lastIndexOf(" ");
          if (lastSpace > 0) {
            return text.substring(0, lastSpace).trim() + "...";
          }

          return truncated.trim() + "...";
        }

        // Generate classification icons for a mitzvah
        getClassificationIcons(mitzvah) {
          if (!mitzvah.classification) return "";

          let icons = [];
          const c = mitzvah.classification;

          // Applies To icons
          if (c.applies_to && c.applies_to.length > 0) {
            if (c.applies_to.includes("All Israel") || (c.applies_to.includes("Men") && c.applies_to.includes("Women"))) {
              icons.push('<span class="icon-badge icon-all" title="All Israel">👥</span>');
            } else if (c.applies_to.includes("Men")) {
              icons.push('<span class="icon-badge icon-men" title="Men">👨</span>');
            } else if (c.applies_to.includes("Women")) {
              icons.push('<span class="icon-badge icon-women" title="Women">👩</span>');
            }
            if (c.applies_to.includes("Kohanim")) {
              icons.push('<span class="icon-badge icon-men" title="Kohanim">🕊️</span>');
            }
            if (c.applies_to.includes("Levites")) {
              icons.push('<span class="icon-badge icon-men" title="Levites">📜</span>');
            }
          }

          // Time scope icons
          if (c.time_scope) {
            if (c.time_scope === "Always") {
              icons.push('<span class="icon-badge icon-time-always" title="Always">⏰</span>');
            } else if (c.time_scope.includes("Festival") || c.time_scope.includes("Holiday")) {
              icons.push('<span class="icon-badge icon-time-festival" title="Festival/Holiday">🎊</span>');
            } else if (c.time_scope.includes("Temple")) {
              icons.push('<span class="icon-badge icon-time-conditional" title="Temple Era">🏛️</span>');
            } else {
              icons.push('<span class="icon-badge icon-time-conditional" title="' + c.time_scope + '">⏳</span>');
            }
          }

          // Location icons
          if (c.location) {
            if (c.location.includes("Temple")) {
              icons.push('<span class="icon-badge icon-location-temple" title="Temple">🏛️</span>');
            } else if (c.location.includes("Eretz Yisrael") || c.location.includes("Israel")) {
              icons.push('<span class="icon-badge icon-location-israel" title="Eretz Yisrael">🇮🇱</span>');
            } else if (c.location === "Anywhere") {
              icons.push('<span class="icon-badge icon-location-anywhere" title="Anywhere">🌍</span>');
            }
          }

          return icons.join("");
        }

        async loadData() {
          try {
            // Try to load via fetch first (for server mode)
            // Fall back to window globals for standalone file:// usage
            let dataLoadedFromFetch = false;

            try {
              const enResponse = await fetch("mitzvot_data.json");
              if (enResponse.ok) {
                this.data = await enResponse.json();
                dataLoadedFromFetch = true;
              }
            } catch (fetchErr) {
              console.log("Fetch failed, using embedded data for standalone mode:", fetchErr.message);
            }

            // If fetch failed, use window globals (standalone mode)
            if (!dataLoadedFromFetch && window.MITZVOT_DATA_EN) {
              console.log("Loading from embedded data (standalone file:// mode)");
              this.data = window.MITZVOT_DATA_EN;
            }

            // Ensure we have data
            if (!this.data) {
              throw new Error("No mitzvot data available (neither fetch nor embedded)");
            }

            // Try to load Hebrew data completely
            try {
              let heDataLoaded = false;

              // Try fetch first
              try {
                const heResponse = await fetch("mitzvot_data_he.json");
                if (heResponse.ok) {
                  this.heData = await heResponse.json();
                  heDataLoaded = true;
                }
              } catch (heFetchErr) {
                // Fetch failed, will try embedded below
              }

              // Fall back to embedded
              if (!heDataLoaded && window.MITZVOT_DATA_HE) {
                this.heData = window.MITZVOT_DATA_HE;
                heDataLoaded = true;
              }

              if (heDataLoaded && this.heData) {
                // Create map for Hebrew titles
                const heTitleById = new Map(this.heData.mitzvot.map((m) => [m.id, m.title]));

                // Augment English mitzvot with Hebrew titles when available
                this.data.mitzvot = this.data.mitzvot.map((m) => ({
                  ...m,
                  title_he: heTitleById.get(m.id) || null,
                }));
              } else {
                console.warn("Hebrew data not available");
              }
            } catch (heErr) {
              console.warn("Failed to load Hebrew data, proceeding with English only.", heErr);
            }

            this.filteredData = [...this.data.mitzvot];
          } catch (error) {
            console.error("Error loading data:", error);
            throw error;
          }
        }

        initImagesFromManifest() {
          try {
            const manifest = window.MITZVOT_IMAGES_MANIFEST;
            if (manifest && manifest.byId) {
              for (const idStr of Object.keys(manifest.byId)) {
                const id = parseInt(idStr, 10);
                if (!Number.isNaN(id)) this.mitzvotWithImages.add(id);
              }
              console.log(`Loaded ${this.mitzvotWithImages.size} mitzvot with images from manifest`);
            } else {
              console.warn("Images manifest not found; card icon visibility may be inaccurate.");
            }
          } catch (e) {
            console.warn("Failed to initialize images from manifest", e);
          }
        }

        setupEventListeners() {
          // Search
          document.getElementById("searchInput").addEventListener("input", (e) => {
            this.filterData();
          });

          // Type filter
          document.getElementById("typeFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          // Book filter
          document.getElementById("bookFilter").addEventListener("change", (e) => {
            // Reset parasha filter when book changes
            if (this.selects.parasha) {
              this.selects.parasha.setValue("", true);
            } else {
              document.getElementById("parashaFilter").value = "";
            }
            this.renderParashaFilter();
            this.filterData();
          });

          // Parasha filter
          document.getElementById("parashaFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          // Classification filters
          document.getElementById("categoryFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          document.getElementById("appliesToFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          document.getElementById("locationFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          document.getElementById("timeScopeFilter").addEventListener("change", (e) => {
            this.filterData();
          });

          // Sort buttons
          document.querySelectorAll(".sort-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const sortField = e.target.dataset.sort;
              this.setSort(sortField);
            });
          });

          // Sortable table headers
          document.querySelectorAll("th.sortable").forEach((th) => {
            th.addEventListener("click", (e) => {
              const sortField = e.currentTarget.dataset.sort;
              this.setSort(sortField);
            });
          });
        }

        setSort(field) {
          if (this.sortField === field) {
            this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
          } else {
            this.sortField = field;
            this.sortDirection = "asc";
          }

          // Update active sort button
          document.querySelectorAll(".sort-btn").forEach((btn) => {
            btn.classList.remove("active");
          });
          const activeBtn = document.querySelector(`[data-sort="${field}"]`);
          if (activeBtn && activeBtn.classList.contains("sort-btn")) {
            activeBtn.classList.add("active");
          }

          // Update sortable table header indicators
          document.querySelectorAll("th.sortable").forEach((th) => {
            const indicator = th.querySelector(".sort-indicator");
            if (indicator) {
              if (th.dataset.sort === field) {
                th.classList.add("active");
                indicator.textContent = this.sortDirection === "asc" ? "▲" : "▼";
              } else {
                th.classList.remove("active");
                indicator.textContent = "";
              }
            }
          });

          this.sortData();
          this.render();
        }

        sortData() {
          this.filteredData.sort((a, b) => {
            let aVal, bVal;

            // Special handling for book and parasha sorting
            if (this.sortField === "book") {
              aVal = a.book_order || 999;
              bVal = b.book_order || 999;
            } else if (this.sortField === "parasha") {
              aVal = a.global_parasha_order || 999;
              bVal = b.global_parasha_order || 999;
            } else {
              aVal = a[this.sortField];
              bVal = b[this.sortField];

              if (typeof aVal === "string") {
                aVal = aVal.toLowerCase();
                bVal = bVal.toLowerCase();
              }
            }

            if (this.sortDirection === "asc") {
              return aVal > bVal ? 1 : -1;
            } else {
              return aVal < bVal ? 1 : -1;
            }
          });
        }

        filterData() {
          const searchTerm = document.getElementById("searchInput").value.toLowerCase();
          const typeFilter = document.getElementById("typeFilter").value;
          const bookFilter = document.getElementById("bookFilter").value;
          const parashaFilter = document.getElementById("parashaFilter").value;
          const categoryFilter = document.getElementById("categoryFilter").value;
          const appliesToFilter = document.getElementById("appliesToFilter").value;
          const locationFilter = document.getElementById("locationFilter").value;
          const timeScopeFilter = document.getElementById("timeScopeFilter").value;

          this.filteredData = this.data.mitzvot.filter((mitzvah) => {
            const matchesSearch =
              !searchTerm ||
              mitzvah.title.toLowerCase().includes(searchTerm) ||
              (mitzvah.title_he && mitzvah.title_he.toLowerCase().includes(searchTerm)) ||
              mitzvah.description.toLowerCase().includes(searchTerm);

            const matchesType = !typeFilter || mitzvah.type === typeFilter;
            const matchesBook = !bookFilter || mitzvah.book_en === bookFilter;
            const matchesParasha = !parashaFilter || mitzvah.parasha === parashaFilter;

            // Classification filters
            const matchesCategory = !categoryFilter || (mitzvah.classification && mitzvah.classification.category === categoryFilter);
            const matchesAppliesTo = !appliesToFilter || (mitzvah.classification && mitzvah.classification.applies_to && mitzvah.classification.applies_to.includes(appliesToFilter));
            const matchesLocation = !locationFilter || (mitzvah.classification && mitzvah.classification.location === locationFilter);
            const matchesTimeScope = !timeScopeFilter || (mitzvah.classification && mitzvah.classification.time_scope === timeScopeFilter);

            return matchesSearch && matchesType && matchesBook && matchesParasha && matchesCategory && matchesAppliesTo && matchesLocation && matchesTimeScope;
          });

          this.sortData();
          this.currentPage = 1;
          this.render();
        }

        render() {
          this.renderStats();
          this.renderBookFilter();
          this.renderParashaFilter();
          this.renderClassificationFilters();
          this.renderTable();
          this.renderPagination();
        }

        renderStats() {
          const statsContainer = document.getElementById("stats");
          const totalCount = this.filteredData.length;
          const positiveCount = this.filteredData.filter((m) => m.type === "Positive").length;
          const negativeCount = this.filteredData.filter((m) => m.type === "Negative").length;

          statsContainer.innerHTML = `
                    <div class="stat-card stat-total">
                        <i data-lucide="hash" class="stat-icon"></i>
                        <div class="stat-content">
                            <span class="stat-number">${totalCount}</span>
                            <span class="stat-label">Total</span>
                        </div>
                    </div>
                    <div class="stat-card stat-positive">
                        <i data-lucide="circle-plus" class="stat-icon"></i>
                        <div class="stat-content">
                            <span class="stat-number">${positiveCount}</span>
                            <span class="stat-label">Positive</span>
                        </div>
                    </div>
                    <div class="stat-card stat-negative">
                        <i data-lucide="circle-minus" class="stat-icon"></i>
                        <div class="stat-content">
                            <span class="stat-number">${negativeCount}</span>
                            <span class="stat-label">Negative</span>
                        </div>
                    </div>
                `;

          // Initialize Lucide icons
          if (typeof lucide !== "undefined") {
            lucide.createIcons();
          }
        }

        renderParashaFilter() {
          const parashaFilter = document.getElementById("parashaFilter");
          const bookFilter = document.getElementById("bookFilter").value;

          // Get unique parashot with their global order
          const parashotMap = new Map();
          this.data.mitzvot.forEach((m) => {
            if (m.parasha && (!bookFilter || m.book_en === bookFilter)) {
              if (!parashotMap.has(m.parasha)) {
                parashotMap.set(m.parasha, m.global_parasha_order || 999);
              }
            }
          });

          // Sort by global order
          const parashot = Array.from(parashotMap.entries())
            .sort((a, b) => a[1] - b[1])
            .map(([parasha]) => parasha);

          const html = '<option value="">All Parashot</option>' + parashot.map((parasha) => `<option value="${parasha}">${parasha}</option>`).join("");
          if (this.selects.parasha) {
            const ts = this.selects.parasha;
            const prev = ts.getValue();
            ts.clearOptions();
            ts.addOption({ value: "", text: "All Parashot" });
            parashot.forEach((p) => ts.addOption({ value: p, text: p }));
            const next = prev && parashot.includes(prev) ? prev : "";
            ts.setValue(next, true);
            ts.refreshOptions(false);
          } else {
            parashaFilter.innerHTML = html;
          }
        }

        renderBookFilter() {
          const bookFilter = document.getElementById("bookFilter");

          // Get unique books with their order
          const booksMap = new Map();
          this.data.mitzvot.forEach((m) => {
            if (m.book_en) {
              if (!booksMap.has(m.book_en)) {
                booksMap.set(m.book_en, m.book_order || 999);
              }
            }
          });

          // Sort by book order
          const books = Array.from(booksMap.entries())
            .sort((a, b) => a[1] - b[1])
            .map(([book]) => book);

          const html = '<option value="">All Books</option>' + books.map((book) => `<option value="${book}">${book}</option>`).join("");
          if (this.selects.book) {
            const ts = this.selects.book;
            const prev = ts.getValue();
            ts.clearOptions();
            ts.addOption({ value: "", text: "All Books" });
            books.forEach((b) => ts.addOption({ value: b, text: b }));
            ts.setValue(prev || "", true);
            ts.refreshOptions(false);
          } else {
            bookFilter.innerHTML = html;
          }
        }

        renderClassificationFilters() {
          // Get unique values from classifications
          const categories = [...new Set(this.data.mitzvot.filter((m) => m.classification && m.classification.category).map((m) => m.classification.category))].sort();

          const locations = [...new Set(this.data.mitzvot.filter((m) => m.classification && m.classification.location).map((m) => m.classification.location))].sort();

          const timeScopes = [...new Set(this.data.mitzvot.filter((m) => m.classification && m.classification.time_scope).map((m) => m.classification.time_scope))].sort();

          // Get all unique "applies_to" values (flatten arrays)
          const appliesTo = [...new Set(this.data.mitzvot.filter((m) => m.classification && m.classification.applies_to).flatMap((m) => m.classification.applies_to))].sort();

          // Populate category filter
          const categoryFilter = document.getElementById("categoryFilter");
          if (this.selects.category) {
            const ts = this.selects.category;
            ts.clearOptions();
            ts.addOption({ value: "", text: "All Categories" });
            categories.forEach((c) => ts.addOption({ value: c, text: c }));
            ts.refreshOptions(false);
          } else {
            categoryFilter.innerHTML = '<option value="">All Categories</option>' + categories.map((cat) => `<option value="${cat}">${cat}</option>`).join("");
          }

          // Populate applies to filter
          const appliesToFilter = document.getElementById("appliesToFilter");
          if (this.selects.appliesTo) {
            const ts = this.selects.appliesTo;
            ts.clearOptions();
            ts.addOption({ value: "", text: "Applies To: All" });
            appliesTo.forEach((p) => ts.addOption({ value: p, text: p }));
            ts.refreshOptions(false);
          } else {
            appliesToFilter.innerHTML = '<option value="">Applies To: All</option>' + appliesTo.map((person) => `<option value="${person}">${person}</option>`).join("");
          }

          // Populate location filter
          const locationFilter = document.getElementById("locationFilter");
          if (this.selects.location) {
            const ts = this.selects.location;
            ts.clearOptions();
            ts.addOption({ value: "", text: "All Locations" });
            locations.forEach((l) => ts.addOption({ value: l, text: l }));
            ts.refreshOptions(false);
          } else {
            locationFilter.innerHTML = '<option value="">All Locations</option>' + locations.map((loc) => `<option value="${loc}">${loc}</option>`).join("");
          }

          // Populate time scope filter
          const timeScopeFilter = document.getElementById("timeScopeFilter");
          if (this.selects.timeScope) {
            const ts = this.selects.timeScope;
            ts.clearOptions();
            ts.addOption({ value: "", text: "All Time Scopes" });
            timeScopes.forEach((t) => ts.addOption({ value: t, text: t }));
            ts.refreshOptions(false);
          } else {
            timeScopeFilter.innerHTML = '<option value="">All Time Scopes</option>' + timeScopes.map((ts) => `<option value="${ts}">${ts}</option>`).join("");
          }
        }

        renderTable() {
          const tableBody = document.getElementById("mitzvotTableBody");
          const startIndex = (this.currentPage - 1) * this.itemsPerPage;
          const endIndex = startIndex + this.itemsPerPage;
          const pageData = this.filteredData.slice(startIndex, endIndex);

          tableBody.innerHTML = pageData
            .map((mitzvah) => {
              // Find corresponding Hebrew data
              const mitzvahHe = this.heData ? this.heData.mitzvot.find((m) => m.id === mitzvah.id) : null;

              // Build title based on selected language
              const heTitle = mitzvah.title_he || (mitzvahHe ? mitzvahHe.title : null);
              let titleHtml = "";
              if (this.tableLanguage === "en") {
                titleHtml = `<div class="title-en">${mitzvah.title}</div>`;
              } else if (this.tableLanguage === "he") {
                if (heTitle) {
                  titleHtml = `<div class="title-he" lang="he" dir="rtl">${heTitle}</div>`;
                } else {
                  // Fallback to English if no Hebrew title
                  titleHtml = `<div class="title-en">${mitzvah.title}</div>`;
                }
              } else {
                // both
                titleHtml = `<div class="title-en">${mitzvah.title}</div>`;
                if (heTitle) {
                  titleHtml += `<div class="title-he" lang="he" dir="rtl">${heTitle}</div>`;
                }
              }

              // Build description based on selected language
              let descriptionHtml = "";
              if (this.tableLanguage === "en") {
                descriptionHtml = this.truncateText(mitzvah.description, 150);
              } else if (this.tableLanguage === "he" && mitzvahHe && mitzvahHe.description) {
                descriptionHtml = `<span class="text-he" lang="he" dir="rtl">${this.truncateText(mitzvahHe.description, 150)}</span>`;
              } else if (this.tableLanguage === "both") {
                descriptionHtml = `<div>${this.truncateText(mitzvah.description, 150)}</div>`;
                if (mitzvahHe && mitzvahHe.description) {
                  descriptionHtml += `<div class="text-he" lang="he" dir="rtl" style="margin-top: 8px; font-size: 0.95em;">${this.truncateText(mitzvahHe.description, 150)}</div>`;
                }
              }

              // Build parasha based on selected language
              const heParasha = mitzvahHe && (mitzvahHe.parasha_he || mitzvahHe.parasha) ? mitzvahHe.parasha_he || mitzvahHe.parasha : null;
              let parashaHtml = "";
              if (this.tableLanguage === "en") {
                parashaHtml = `<div class="parasha-en">${mitzvah.parasha || ""}</div>`;
              } else if (this.tableLanguage === "he") {
                if (heParasha) {
                  parashaHtml = `<div class="parasha-he text-he" lang="he" dir="rtl">${heParasha}</div>`;
                } else {
                  parashaHtml = `<div class="parasha-en">${mitzvah.parasha || ""}</div>`;
                }
              } else {
                // both
                parashaHtml = `<div class="parasha-en">${mitzvah.parasha || ""}</div>`;
                if (heParasha) {
                  parashaHtml += `<div class="parasha-he text-he" lang="he" dir="rtl">${heParasha}</div>`;
                }
              }

              return `
          <tr>
            <td class="mitzvah-number">${mitzvah.id}</td>
            <td><span class="mitzvah-type ${mitzvah.type.toLowerCase()}">${mitzvah.type}</span></td>
            <td class="mitzvah-title">${titleHtml}</td>
            <td class="classification-icons">${this.getClassificationIcons(mitzvah)}</td>
            <td class="description">${descriptionHtml}</td>
            <td class="parasha">${parashaHtml}</td>
            <td>
              <div class="details-actions">
                <button class="details-toggle" onclick="app.openSidebar(${mitzvah.id})" title="Show full details">
                  📋
                </button>
                ${
                  this.cardsEnabled && this.mitzvotWithImages.has(mitzvah.id)
                    ? `<button class="card-toggle" onclick="app.openCardModal(${mitzvah.id})" title="View as card">
                  🃏
                </button>`
                    : ""
                }
              </div>
            </td>
          </tr>
        `;
            })
            .join("");

          // Show table container and language toggle
          document.getElementById("tableContainer").style.display = "block";
          document.getElementById("tableLanguageToggle").style.display = "block";
          document.getElementById("loading").style.display = "none";
        }

        renderPagination() {
          const pagination = document.getElementById("pagination");
          const totalPages = Math.ceil(this.filteredData.length / this.itemsPerPage);

          if (totalPages <= 1) {
            pagination.style.display = "none";
            return;
          }

          pagination.style.display = "block";

          let paginationHTML = "";

          // Previous button
          paginationHTML += `<button ${this.currentPage === 1 ? "disabled" : ""} onclick="app.goToPage(${this.currentPage - 1})">Previous</button>`;

          // Page numbers
          const startPage = Math.max(1, this.currentPage - 2);
          const endPage = Math.min(totalPages, this.currentPage + 2);

          if (startPage > 1) {
            paginationHTML += `<button onclick="app.goToPage(1)">1</button>`;
            if (startPage > 2) {
              paginationHTML += `<span>...</span>`;
            }
          }

          for (let i = startPage; i <= endPage; i++) {
            const isCurrent = i === this.currentPage;
            paginationHTML += `<button class="${isCurrent ? "current" : ""}" onclick="app.goToPage(${i})">${i}</button>`;
          }

          if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
              paginationHTML += `<span>...</span>`;
            }
            paginationHTML += `<button onclick="app.goToPage(${totalPages})">${totalPages}</button>`;
          }

          // Next button
          paginationHTML += `<button ${this.currentPage === totalPages ? "disabled" : ""} onclick="app.goToPage(${this.currentPage + 1})">Next</button>`;

          pagination.innerHTML = paginationHTML;
        }

        goToPage(page) {
          const totalPages = Math.ceil(this.filteredData.length / this.itemsPerPage);
          if (page >= 1 && page <= totalPages) {
            this.currentPage = page;
            this.renderTable();
            this.renderPagination();
          }
        }

        openSidebar(id) {
          this.currentMitzvahId = id;
          this.renderSidebarContent();

          // Show sidebar
          document.getElementById("sidebarOverlay").classList.add("show");
          document.getElementById("sidebar").classList.add("show");
        }

        setLanguage(lang) {
          this.currentLanguage = lang;

          // Update active button
          document.querySelectorAll(".language-btn").forEach((btn) => {
            btn.classList.remove("active");
            if (btn.dataset.lang === lang) {
              btn.classList.add("active");
            }
          });

          // Re-render content if sidebar is open
          if (this.currentMitzvahId) {
            this.renderSidebarContent();
          }
        }

        setTableLanguage(lang) {
          this.tableLanguage = lang;

          // Update active button
          document.querySelectorAll(".table-lang-btn").forEach((btn) => {
            btn.classList.remove("active");
            if (btn.dataset.lang === lang) {
              btn.classList.add("active");
            }
          });

          // Re-render table with new language
          this.renderTable();
        }

        toggleMoreFilters() {
          this.moreFiltersVisible = !this.moreFiltersVisible;
          const secondaryFilters = document.getElementById("secondaryFilters");
          const moreFiltersText = document.getElementById("moreFiltersText");
          const moreFiltersIcon = document.getElementById("moreFiltersIcon");

          if (this.moreFiltersVisible) {
            secondaryFilters.style.display = "flex";
            moreFiltersText.textContent = "Less Filters";
            moreFiltersIcon.textContent = "▲";
          } else {
            secondaryFilters.style.display = "none";
            moreFiltersText.textContent = "More Filters";
            moreFiltersIcon.textContent = "▼";
          }
        }

        renderSidebarContent() {
          const mitzvah = this.data.mitzvot.find((m) => m.id === this.currentMitzvahId);
          if (!mitzvah) return;

          // Find corresponding Hebrew data
          const mitzvahHe = this.heData ? this.heData.mitzvot.find((m) => m.id === this.currentMitzvahId) : null;

          // Set title based on language
          const sidebarTitle = document.getElementById("sidebarTitle");
          if (this.currentLanguage === "en") {
            sidebarTitle.textContent = mitzvah.title;
          } else if (this.currentLanguage === "he" && mitzvahHe) {
            sidebarTitle.innerHTML = `<span class="text-he">${mitzvahHe.title}</span>`;
          } else if (this.currentLanguage === "both") {
            sidebarTitle.innerHTML = `${mitzvah.title}<br><span class="text-he">${mitzvahHe ? mitzvahHe.title : ""}</span>`;
          }

          // Build content
          const sidebarContent = document.getElementById("sidebarContent");
          let html = '<div class="sidebar-meta">';
          html += `<div><strong>ID:</strong> ${mitzvah.id}</div>`;
          html += `<div><strong>Type:</strong> ${mitzvah.type}</div>`;
          html += `<div><strong>Parasha:</strong> ${mitzvah.parasha}</div>`;
          html += "</div>";

          // Description
          if (this.currentLanguage === "en" && mitzvah.description) {
            html += `<div class="sidebar-section"><h3>Description</h3><p>${mitzvah.description}</p></div>`;
          } else if (this.currentLanguage === "he" && mitzvahHe && mitzvahHe.description) {
            html += `<div class="sidebar-section"><h3 class="text-he">תיאור</h3><p class="text-he">${mitzvahHe.description}</p></div>`;
          } else if (this.currentLanguage === "both") {
            html += '<div class="sidebar-section"><h3>Description / תיאור</h3>';
            if (mitzvah.description) {
              html += `<div class="interlinear-container"><div class="interlinear-en">${mitzvah.description}</div>`;
              if (mitzvahHe && mitzvahHe.description) {
                html += `<div class="interlinear-he">${mitzvahHe.description}</div>`;
              }
              html += "</div>";
            }
            html += "</div>";
          }

          // Full text
          if (this.currentLanguage === "en" && mitzvah.full_text) {
            html += `<div class="sidebar-section"><h3>Full Text</h3><p>${mitzvah.full_text}</p></div>`;
          } else if (this.currentLanguage === "he" && mitzvahHe && mitzvahHe.full_text) {
            html += `<div class="sidebar-section"><h3 class="text-he">טקסט מלא</h3><p class="text-he">${mitzvahHe.full_text}</p></div>`;
          } else if (this.currentLanguage === "both") {
            html += '<div class="sidebar-section"><h3>Full Text / טקסט מלא</h3>';
            if (mitzvah.full_text) {
              html += `<div class="interlinear-container"><div class="interlinear-en">${mitzvah.full_text}</div>`;
              if (mitzvahHe && mitzvahHe.full_text) {
                html += `<div class="interlinear-he">${mitzvahHe.full_text}</div>`;
              }
              html += "</div>";
            }
            html += "</div>";
          }

          // Details
          if (this.currentLanguage === "en" && mitzvah.details && Array.isArray(mitzvah.details)) {
            html += '<div class="sidebar-section"><h3>Details</h3>';
            mitzvah.details.forEach((detail) => {
              html += `<p>${detail}</p>`;
            });
            html += "</div>";
          } else if (this.currentLanguage === "he" && mitzvahHe && mitzvahHe.details && Array.isArray(mitzvahHe.details)) {
            html += '<div class="sidebar-section"><h3 class="text-he">פרטים</h3>';
            mitzvahHe.details.forEach((detail) => {
              html += `<p class="text-he">${detail}</p>`;
            });
            html += "</div>";
          } else if (this.currentLanguage === "both") {
            html += '<div class="sidebar-section"><h3>Details / פרטים</h3>';
            const maxLength = Math.max(mitzvah.details ? mitzvah.details.length : 0, mitzvahHe && mitzvahHe.details ? mitzvahHe.details.length : 0);
            for (let i = 0; i < maxLength; i++) {
              html += '<div class="interlinear-container">';
              if (mitzvah.details && mitzvah.details[i]) {
                html += `<div class="interlinear-en">${mitzvah.details[i]}</div>`;
              }
              if (mitzvahHe && mitzvahHe.details && mitzvahHe.details[i]) {
                html += `<div class="interlinear-he">${mitzvahHe.details[i]}</div>`;
              }
              html += "</div>";
            }
            html += "</div>";
          }

          // Classification (English only for now)
          if (mitzvah.classification) {
            const c = mitzvah.classification;
            html += '<div class="sidebar-section sidebar-classification"><h3>Classification</h3>';

            if (c.category) {
              html += `<div><strong>Category:</strong> ${c.category}</div>`;
            }
            if (c.sub_category) {
              html += `<div><strong>Sub-Category:</strong> ${c.sub_category}</div>`;
            }
            if (c.applies_to && Array.isArray(c.applies_to)) {
              html += `<div><strong>Applies To:</strong> ${c.applies_to.join(", ")}</div>`;
            }
            if (c.location) {
              html += `<div><strong>Location:</strong> ${c.location}</div>`;
            }
            if (c.time_scope) {
              html += `<div><strong>Time Scope:</strong> ${c.time_scope}</div>`;
            }
            if (c.source_refs && Array.isArray(c.source_refs)) {
              html += `<div><strong>Sources:</strong> ${c.source_refs.join(", ")}</div>`;
            }

            html += "</div>";
          }

          sidebarContent.innerHTML = html;
        }

        closeSidebar() {
          document.getElementById("sidebarOverlay").classList.remove("show");
          document.getElementById("sidebar").classList.remove("show");
        }

        openCardModal(id) {
          // Guard: Card feature disabled
          if (!this.cardsEnabled) return;
          this.currentMitzvahId = id;
          this.renderCardContent();

          // Show modal
          document.getElementById("cardModalOverlay").classList.add("show");
          document.getElementById("cardModal").classList.add("show");
        }

        closeCardModal() {
          document.getElementById("cardModalOverlay").classList.remove("show");
          document.getElementById("cardModal").classList.remove("show");
        }

        renderCardContent() {
          const mitzvah = this.data.mitzvot.find((m) => m.id === this.currentMitzvahId);
          if (!mitzvah) return;

          const mitzvahHe = this.heData ? this.heData.mitzvot.find((m) => m.id === this.currentMitzvahId) : null;

          const cardContainer = document.getElementById("mtgCard");

          // Determine card frame color based on type
          const frameClass = mitzvah.type === "Positive" ? "positive-frame" : "negative-frame";

          // Get classification info
          const c = mitzvah.classification || {};

          let html = `<div class="mtg-card-inner ${frameClass}">`;

          // Card Header
          html += '<div class="mtg-card-header">';
          html += `<div class="mtg-card-title">${mitzvah.title}</div>`;
          if (mitzvahHe && mitzvahHe.title) {
            html += `<div class="mtg-card-title-he">${mitzvahHe.title}</div>`;
          }
          html += "</div>";

          // Card Type Line
          html += '<div class="mtg-card-type-line">';
          html += `<span class="mtg-type">${mitzvah.type} Commandment</span>`;
          if (c.category) {
            html += ` — <span class="mtg-subtype">${c.category}</span>`;
          }
          html += "</div>";

          // Card Image with extension fallbacks: .png -> .jpg -> .jpeg -> placeholder
          html += '<div class="mtg-card-image">';
          const imagePath = `images/${mitzvah.id}.png`;
          // data-ext-index=0 means current ext is png (index 0 of IMAGE_EXT_FALLBACKS)
          html += `<img src="${imagePath}" alt="${mitzvah.title}" class="mtg-card-image-actual" data-ext-index="0" onerror="loadMitzvahImageFallback(this, '${mitzvah.id}')" />`;
          html += '<div class="mtg-card-image-placeholder" style="display: none;">';
          html += "<span>🖼️</span>";
          html += '<span class="placeholder-text">Image Coming Soon</span>';
          html += "</div>";
          html += "</div>";

          // Classification Bar - Category and Icons between image and text box
          html += '<div class="mtg-card-icons-bar">';

          // Category - Sub-category on the left
          if (c.category || c.sub_category) {
            html += '<div class="mtg-card-category">';
            if (c.category) {
              html += c.category;
            }
            if (c.category && c.sub_category) {
              html += " — ";
            }
            if (c.sub_category) {
              html += `<span class="mtg-card-subcategory">${c.sub_category}</span>`;
            }
            html += "</div>";
          }

          // Icons on the right
          const icons = this.getClassificationIcons(mitzvah);
          if (icons) {
            html += `<div class="mtg-card-icons">${icons}</div>`;
          }

          html += "</div>";

          // Card Text Box
          html += '<div class="mtg-card-text-box">';

          // Description
          if (mitzvah.description) {
            const descText = this.stripHtmlTags(mitzvah.description);
            html += `<div class="mtg-card-description">${descText}</div>`;
          }

          // Source reference
          if (mitzvah.parasha) {
            html += `<div class="mtg-card-flavor"><em>Parashat ${mitzvah.parasha}</em></div>`;
          }

          html += "</div>";

          // Card Footer (Edition info)
          html += '<div class="mtg-card-footer">';
          html += `<span class="mtg-card-set-info">${mitzvah.book_en || "Torah"}</span>`;
          html += `<span class="mtg-card-number">${mitzvah.id}/613</span>`;
          html += "</div>";

          html += "</div>";

          cardContainer.innerHTML = html;
        }

        stripHtmlTags(html) {
          const temp = document.createElement("div");
          temp.innerHTML = html;
          return temp.textContent || temp.innerText || "";
        }

        showError() {
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "block";
        }
      }

      // Initialize the app when the page loads
      let app;
      document.addEventListener("DOMContentLoaded", () => {
        app = new MitzvotApp();

        // Show beta notice on first visit
        if (!localStorage.getItem("betaNoticeSeen")) {
          Swal.fire({
            icon: "warning",
            title: "⚠️ Beta Notice",
            html: `
              <p>This project is still new and evolving, so there may be some errors or inaccuracies.</p>
              <p>If you're citing information, please double-check it with your own or official sources.</p>
              <p>Feedback and corrections are always welcome at <a href="mailto:moxaku@gmail.com">moxaku@gmail.com</a>.</p>
            `,
            confirmButtonText: "Got it!",
            confirmButtonColor: "#0d6efd",
            allowOutsideClick: false,
          }).then(() => {
            localStorage.setItem("betaNoticeSeen", "true");
          });
        }
      });
    </script>
  </body>
</html>
